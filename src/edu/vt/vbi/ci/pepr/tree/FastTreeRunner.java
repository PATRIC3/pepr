package edu.vt.vbi.ci.pepr.tree;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;

import edu.vt.vbi.ci.pepr.alignment.SequenceAlignment;
import edu.vt.vbi.ci.util.CommandResults;
import edu.vt.vbi.ci.util.RemoteHost;
import edu.vt.vbi.ci.util.file.TextFile;

/**
 * This class runs the tree-building program FastTree.
 * 
 * @author enordber
 *
 */
public class FastTreeRunner implements Runnable{

	private SequenceAlignment alignment;
	private String result;
	private RemoteHost host;
	private String ftPath = null;
	private String runName;
	private String constraints;
	private boolean useRaxmlBranchLengths = false;
	private int threadCount = 1;
	private boolean nucleotide = false;

	public FastTreeRunner() {
		host = RemoteHost.getLocalHost();
	}

	public void run() {
		String fastTreePath = getFastTreePath();

		//create file for alignment
		File workingDir = new File(System.getProperty("user.dir"));
		try {
			File alignmentFile = File.createTempFile(alignment.getName(), ".faa", workingDir);
			//write alignment to file, as fasta format.
			FileWriter fw = new FileWriter(alignmentFile);
			fw.write(alignment.getAlignmentAsFasta());
			fw.write("\n");
			fw.flush();
			fw.close();
			alignmentFile.deleteOnExit();

			//if constraints have been provided, create constraints file
			String treeConstraints = getConstraints();
			String constraintsFileName = alignmentFile.getName() + ".con";
			boolean useConstraints = false;
			if(treeConstraints != null) {
				useConstraints = true;
				fw = new FileWriter(constraintsFileName);
				fw.write(treeConstraints);
				fw.flush();
				fw.close();
				new File(constraintsFileName).deleteOnExit();
			}
			//create FastTree command
			String alignmentFileName = alignmentFile.getName();
			String fastTreeCommand = fastTreePath + " -gamma -nosupport ";
			
			if(nucleotide) {
				fastTreeCommand = fastTreePath + " -gtr -nt -nosupport ";
			}

			if(useConstraints) {
				fastTreeCommand = 
					fastTreeCommand + "-constraints " + 
					constraintsFileName + " ";
			}
			
			fastTreeCommand = fastTreeCommand + alignmentFileName;

			//execute the command and capture the output. The newick format tree
			//is written to stdout.
			System.out.println("running FastTree with command: " 
					+ fastTreeCommand);
			CommandResults results = host.executeCommand(fastTreeCommand);
			if(results.getStdout().length > 0) {
				String treeString = results.getStdout()[0];
				if(getUseRaxmlBranchLengths()) {
					String raxmlTreeString = getRaxmlBranchLengths(treeString, alignment);
					if(raxmlTreeString == null) {
						System.out.println("FastTreeRunner had a problem adding RAxML branch lengths to the tree generated by FastTree");
						System.out.println("The unaltered FastTree tree is being returned instead.");
					} else {
						treeString = raxmlTreeString;
					}
				}
				setResult(treeString);
			} else {
				System.out.println("No FastTree result reported to stdout. Here is stderr:");
				String[] stderr = results.getStderr();
				for(int i = 0; i < stderr.length; i++) {
					System.out.println(stderr[i]);
				}
			}
		} catch(IOException ioe) {
			ioe.printStackTrace();
		}
	}

	/**
	 * Takes an input tree string and runs RAxML to get new ML branch lengths.
	 * @param treeString
	 * @return
	 */
	private String getRaxmlBranchLengths(String treeString, SequenceAlignment alignment) {
		String r = null;
		//get raxml path
		String raxmlPath = host.getCommandPath("raxmlHPC");
		if(raxmlPath == null || raxmlPath.trim().startsWith("no ")) {
			raxmlPath = host.getCommandPath("raxml");
		}

		if(getThreadCount() > 1) {
			raxmlPath = host.getCommandPath("raxmlHPC-PTHREADS");
		}

		try {
			File userDir = new File(System.getProperty("user.dir"));
			//write alignment to file
			File alignFile = File.createTempFile("align", ".phy", userDir);
			FileWriter alignWriter = new FileWriter(alignFile);
			alignWriter.write(alignment.getAlignmentAsExtendedPhylipUsingTaxonNames());
			alignWriter.flush();
			alignWriter.close();
			String alignmentFileName = alignFile.getName();
			
			//write treeString to a file
			File intreeFile = File.createTempFile("intree", ".nwk", userDir);
			FileWriter fw = new FileWriter(intreeFile);
			fw.write(treeString);
			fw.flush();
			fw.close();

			String intreeFileName = intreeFile.getName();
			
			//create raxml command String
			String raxmlCommand = raxmlPath + 
			       " -f e -m PROTGAMMAWAG ";
			if(getThreadCount() > 1) {
				raxmlCommand = raxmlCommand + " -T " + getThreadCount();
			}
			
			raxmlCommand = raxmlCommand + " -s " + alignmentFileName +
			              " -n " + getRunName() + " -t " + intreeFileName;
			
			//run raxml
			System.out.println("running command to add raxml branch lengths to " +
					"FastTree tree:");
			System.out.println(raxmlCommand);
			CommandResults raxmlResults = host.executeCommand(raxmlCommand);

			//read raxml result file
			String raxmlTreeFileName = "RAxML_result." + getRunName();
			TextFile raxmlTreeFile = new TextFile(raxmlTreeFileName);

			r = raxmlTreeFile.toString();
			alignFile.delete();
			intreeFile.delete();
			raxmlTreeFile.getFile().delete();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return r;
	}

	private String getFastTreePath() {
		if(ftPath == null) {
			ftPath = host.getCommandPath("FastTree_WAG");
		}
		return ftPath;
	}

	public void setFastTreePath(String path) {
		ftPath = path;
	}

	RemoteHost getHost() {
		return host;
	}

	public void setHost(RemoteHost host) {
		this.host = host;
	}

	public SequenceAlignment getAlignment() {
		return alignment;
	}

	public void setAlignment(SequenceAlignment alignment) {
		this.alignment = alignment;
	}
	
	public void setConstraints(String constraints) {
		this.constraints = constraints;
	}
	
	public void setConstraintTree(String treeString) {
		if(treeString != null) {
			String constr = getFastTreeConstraintsForTree(treeString);
			setConstraints(constr);
		}
	}
	
	private String getConstraints() {
		return constraints;
	}

	public String getResult() {
		return result;
	}

	private void setResult(String result) {
		this.result = result;
	}
	
	private String getFastTreeConstraintsForTree(String treeString) {
		String r = null;
		AdvancedTree tree = new AdvancedTree(treeString);
		String[] taxa = tree.getLeafLabels();
		Arrays.sort(taxa);

		int nodeCount = tree.getNodeCount();
		int[][] presentAbsent = new int[taxa.length][nodeCount];

		for(int i = 0; i < nodeCount; i++) {
			String[] leavesForNode = tree.getDescendantLeaves(i);
			for(int j = 0; j < leavesForNode.length; j++) {
				int leafIndex = Arrays.binarySearch(taxa, leavesForNode[j]);
				presentAbsent[leafIndex][i] = 1;
			}
		}

		StringBuffer sb = new StringBuffer();
		for(int i = 0; i < taxa.length; i++) {
			sb.append(">");
			sb.append(taxa[i]);
			sb.append("\n");
			for(int j = 0; j < presentAbsent[i].length; j++) {
				sb.append(""+ presentAbsent[i][j]);
			}
			sb.append("\n");
		}

		r = sb.toString();
		return r;
	}

	public boolean getUseRaxmlBranchLengths() {
		return useRaxmlBranchLengths;
	}

	public void setUseRaxmlBranchLengths(boolean useRaxmlBranchLengths) {
		this.useRaxmlBranchLengths = useRaxmlBranchLengths;
	}

	public int getThreadCount() {
		return threadCount;
	}

	public void setThreadCount(int threadCount) {
		this.threadCount = threadCount;
	}

	private String getRunName() {
		return runName;
	}

	public void setRunName(String runName) {
		this.runName = runName;
	}

	public void setNucleoide(boolean nuc) {
		nucleotide = nuc;
	}


}
